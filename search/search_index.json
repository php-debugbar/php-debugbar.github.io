{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PHP Debug Bar","text":"<p>Displays a debug bar in the browser with information from php. No more <code>var_dump()</code> in your code!</p> <p>Note: Debug Bar is for development use only. Never install this on websites that are publicly accessible.</p> <p></p> <p>Features:</p> <ul> <li>Generic debug bar</li> <li>Easy to integrate with any project</li> <li>Clean, fast and easy to use interface</li> <li>Handles AJAX request</li> <li>Includes generic data collectors and collectors for well known libraries</li> <li>The client side bar is 100% coded in javascript</li> <li>Easily create your own collectors and their associated view in the bar</li> <li>Save and re-open previous requests</li> <li>Very well documented</li> </ul> <p>Includes collectors for:</p> <ul> <li>PDO</li> <li>CacheCache</li> <li>Doctrine</li> <li>Monolog</li> <li>Propel</li> <li>Slim</li> <li>Symfony Mailer</li> <li>Swift Mailer</li> <li>Twig</li> </ul> <p>Checkout the demo for examples and phpdebugbar.com for a live example.</p> <p>Integrations with other frameworks:</p> <ul> <li>Laravel</li> <li>Atomik</li> <li>XOOPS</li> <li>Zend Framework 2</li> <li>Phalcon</li> <li>SilverStripe</li> <li>Grav CMS</li> <li>TYPO3</li> <li>Joomla</li> <li>Drupal</li> <li>October CMS</li> <li>Framework-agnostic middleware and PSR-7 with php-middleware/phpdebugbar</li> <li>Dotkernel Frontend Application</li> </ul> <p>(drop me a message or submit a PR to add your DebugBar related project here)</p>"},{"location":"collectors/base/","title":"Base collectors","text":"<p>Collectors provided in the <code>DebugBar\\DataCollector</code> namespace.</p>"},{"location":"collectors/base/#messages","title":"Messages","text":"<p>Provides a way to log messages (compatible with PSR-3 logger). You can call the <code>useHtmlVarDumper()</code> function to use VarDumper's interactive HTML dumper for interactively rendering complex variables.  If you do that, you must properly render inline assets when rendering the debug bar in addition to the normal js/css static assets.</p> <pre><code>$c = new DebugBar\\DataCollector\\MessagesCollector();\n$c-&gt;useHtmlVarDumper(); // Enables prettier dumps of objects; requires inline assets\n$debugbar-&gt;addCollector($c);\n\n$debugbar['messages']-&gt;info('hello world');\n$complicated_variable = array(1, 2, array(3, 4));\n$debugbar['messages']-&gt;info($complicated_variable); // interactive HTML variable dumping\n</code></pre> <p>You can have multiple messages collector by naming them:</p> <pre><code>$debugbar-&gt;addCollector(new MessagesCollector('io_ops'));\n$debugbar['io_ops']-&gt;info('opening files');\n</code></pre> <p>You can aggregate messages collector into other to have a unified view:</p> <pre><code>$debugbar['messages']-&gt;aggregate($debugbar['io_ops']);\n</code></pre> <p>If you don't want to create a standalone tab in the debug bar but still be able to log messages from a different collector, you don't have to add the collector to the debug bar:</p> <pre><code>$debugbar['messages']-&gt;aggregate(new MessagesCollector('io_ops'));\n</code></pre>"},{"location":"collectors/base/#timedata","title":"TimeData","text":"<p>Provides a way to log total execution time as well as taking \"measures\" (ie. measure the execution time of a particular operation).</p> <pre><code>$debugbar-&gt;addCollector(new DebugBar\\DataCollector\\TimeDataCollector());\n\n$debugbar['time']-&gt;startMeasure('longop', 'My long operation');\nsleep(2);\n$debugbar['time']-&gt;stopMeasure('longop');\n\n$debugbar['time']-&gt;measure('My long operation', function()\u00a0{\n    sleep(2);\n});\n</code></pre> <p>Displays the measures on a timeline</p>"},{"location":"collectors/base/#exceptions","title":"Exceptions","text":"<p>Display exceptions</p> <pre><code>$debugbar-&gt;addCollector(new DebugBar\\DataCollector\\ExceptionsCollector());\n\ntry {\n    throw new Exception('foobar');\n} catch (Exception $e) {\n    $debugbar['exceptions']-&gt;addThrowable($e);\n}\n</code></pre>"},{"location":"collectors/base/#pdo","title":"PDO","text":"<p>Logs SQL queries.</p> <pre><code>$debugbar-&gt;addCollector(new DebugBar\\DataCollector\\PDO\\PDOCollector($pdo));\n</code></pre> <p>You can even log queries from multiple <code>PDO</code> connections:</p> <pre><code>$pdoCollector = new DebugBar\\DataCollector\\PDO\\PDOCollector();\n$pdoCollector-&gt;addConnection($pdoRead, 'read-db');\n$pdoCollector-&gt;addConnection($pdoWrite, 'write-db');\n\n$debugbar-&gt;addCollector($pdoCollector);\n</code></pre> <p>If you want to see your PDO requests in the TimeDataCollector, you must add the PDOConnector to the $debugbar first</p> <pre><code>$timeDataCollector = new DebugBar\\DataCollector\\TimeDataCollector();\n$pdoCollector = new DebugBar\\DataCollector\\PDO\\PDOCollector($pdo, $timeDataCollector);\n\n$debugBar-&gt;addCollector($pdoCollector);\n$debugBar-&gt;addCollector($timeDataCollector);\n</code></pre>"},{"location":"collectors/base/#requestdata","title":"RequestData","text":"<p>Collects the data of PHP's global variables.  You can call the <code>useHtmlVarDumper()</code> function to use VarDumper's interactive HTML dumper for rendering the variables.  If you do that, you must properly render inline assets when rendering the debug bar in addition to the normal js/css static assets.</p> <pre><code>$requestDataCollector = new DebugBar\\DataCollector\\RequestDataCollector();\n$requestDataCollector-&gt;useHtmlVarDumper();\n$debugbar-&gt;addCollector($requestDataCollector);\n</code></pre>"},{"location":"collectors/base/#config","title":"Config","text":"<p>Used to display any key/value pairs array.  You can call the <code>useHtmlVarDumper()</code> function to use VarDumper's interactive HTML dumper for rendering the variables.  If you do that, you must properly render inline assets when rendering the debug bar in addition to the normal js/css static assets.</p> <pre><code>$data = array('foo' =&gt; 'bar');\n$configCollector = new DebugBar\\DataCollector\\ConfigCollector($data);\n$configCollector-&gt;useHtmlVarDumper();\n$debugbar-&gt;addCollector($configCollector);\n</code></pre> <p>You can provide a different name for this collector in the second argument of the constructor.</p>"},{"location":"collectors/base/#aggregatedcollector","title":"AggregatedCollector","text":"<p>Aggregates multiple collectors. Do not provide any widgets, you have to add your own controls.</p> <pre><code>$debugbar-&gt;addCollector(new DebugBar\\DataCollector\\AggregatedCollector('all_messages', 'messages', 'time'));\n$debugbar['all_messages']-&gt;addCollector($debugbar['messages']);\n$debugbar['all_messages']-&gt;addCollector(new DebugBar\\DataCollector\\MessagesCollector('mails'));\n$debugbar['all_messages']['mails']-&gt;addMessage('sending mail');\n\n$renderer = $debugbar-&gt;getJavascriptRenderer();\n$renderer-&gt;addControl('all_messages', array(\n    'widget' =&gt; 'PhpDebugBar.Widgets.MessagesWidget',\n    'map' =&gt; 'all_messages',\n    'default' =&gt; '[]',\n));\n</code></pre>"},{"location":"collectors/base/#others","title":"Others","text":"<p>Misc collectors which you can just register:</p> <ul> <li><code>MemoryCollector</code> (memory): Display memory usage</li> <li><code>PhpInfoCollector</code> (php): PHP version number</li> </ul>"},{"location":"collectors/bridge/","title":"Bridge collectors","text":"<p>DebugBar comes with some \"bridge\" collectors. This collectors provides a way to integrate other projects with the DebugBar.</p>"},{"location":"collectors/bridge/#cachecache","title":"CacheCache","text":"<p>http://maximebf.github.io/CacheCache/</p> <p>Displays cache operations using <code>DebugBar\\Bridge\\CacheCacheCollector</code></p> <pre><code>$cache = new CacheCache\\Cache(new CacheCache\\Backends\\Memory());\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\CacheCacheCollector($cache));\n</code></pre> <p>CacheCache uses Monolog for logging, thus it is required to collect data.</p> <p><code>CacheCacheCollector</code> subclasses <code>MonologCollector</code>, thus it can be aggregated in the messages view.</p>"},{"location":"collectors/bridge/#doctrine","title":"Doctrine","text":"<p>http://doctrine-project.org</p> <p>Displays sql queries into an SQL queries view using <code>DebugBar\\Bridge\\DoctrineCollector</code>. You will need to set a <code>Doctrine\\DBAL\\Logging\\DebugStack</code> logger on your connection.</p> <pre><code>$debugStack = new Doctrine\\DBAL\\Logging\\DebugStack();\n$entityManager-&gt;getConnection()-&gt;getConfiguration()-&gt;setSQLLogger($debugStack);\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\DoctrineCollector($debugStack));\n</code></pre> <p><code>DoctrineCollector</code> also accepts an <code>Doctrine\\ORM\\EntityManager</code> as argument provided the <code>SQLLogger</code> is a \u0300DebugStack`.</p>"},{"location":"collectors/bridge/#monolog","title":"Monolog","text":"<p>https://github.com/Seldaek/monolog</p> <p>Integrates Monolog messages into a message view using <code>DebugBar\\Bridge\\MonologCollector</code>.</p> <pre><code>$logger = new Monolog\\Logger('mylogger');\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\MonologCollector($logger));\n</code></pre> <p>Note that multiple logger can be collected:</p> <pre><code>$debugbar['monolog']-&gt;addLogger($logger);\n</code></pre> <p><code>MonologCollector</code> can be aggregated into the <code>MessagesCollector</code>.</p>"},{"location":"collectors/bridge/#propel","title":"Propel","text":"<p>http://propelorm.org/</p> <p>Displays propel queries into an SQL queries view using <code>DebugBar\\Bridge\\PropelCollector</code>. You will need to activate Propel debug mode.</p> <pre><code>// before Propel::init()\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\PropelCollector());\n\nPropel::init('/path/to/config');\n\n// after Propel::init()\n// not mandatory if you set config options by yourself\nDebugBar\\Bridge\\PropelCollector::enablePropelProfiling();\n</code></pre> <p>Queries can be collected on a single connection by providing the <code>PropelPDO</code> object to the <code>PropelCollector</code> as first argument.</p>"},{"location":"collectors/bridge/#slim","title":"Slim","text":"<p>http://slimframework.com</p> <p>Displays message from the Slim logger into a message view using <code>DebugBar\\Bridge\\SlimCollector</code>.</p> <pre><code>$app = new Slim\\Slim();\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\SlimCollector($app));\n</code></pre>"},{"location":"collectors/bridge/#swift-mailer","title":"Swift Mailer","text":"<p>http://swiftmailer.org/</p> <p>Display log messages and sent mail using <code>DebugBar\\Bridge\\SwiftMailer\\SwiftLogCollector</code> and <code>DebugBar\\Bridge\\SwiftMailer\\SwiftMailCollector</code>.</p> <pre><code>$mailer = Swift_Mailer::newInstance(Swift_NullTransport::newInstance());\n$debugbar['messages']-&gt;aggregate(new DebugBar\\Bridge\\SwiftMailer\\SwiftLogCollector($mailer));\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\SwiftMailer\\SwiftMailCollector($mailer));\n</code></pre>"},{"location":"collectors/bridge/#symfony-mailer","title":"Symfony Mailer","text":"<p>https://symfony.com/doc/current/mailer.html</p> <p>Display log messages and sent mail using <code>DebugBar\\Bridge\\Symfony\\SymfonyMailCollector</code></p> <pre><code>use Symfony\\Component\\Mailer\\Event\\SentMessageEvent;\n\n$mailCollector = new DebugBar\\Bridge\\Symfony\\SymfonyMailCollector();\n$debugbar-&gt;addCollector($mailCollector);\n$eventDispatcher-&gt;addListener(SentMessageEvent::class, function (SentMessageEvent $event) use (&amp;$mailCollector): void {\n    $mailCollector-&gt;addSymfonyMessage($event-&gt;getMessage());\n});\n</code></pre>"},{"location":"collectors/bridge/#twig","title":"Twig","text":"<p>http://twig.sensiolabs.org/</p>"},{"location":"collectors/bridge/#version-1-and-2","title":"Version 1 and 2","text":"<p>This collector uses the class <code>Twig_Extension_Profiler</code> to collect info about rendered templates, blocks and macros. You need to inject the root <code>Twig_Profiler_Profile</code> into the collector:</p> <pre><code>$loader = new Twig_Loader_Filesystem('.');\n$env = new Twig_Environment($loader);\n$profile = new Twig_Profiler_Profile();\n$env-&gt;addExtension(new Twig_Extension_Profiler($profile));\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\TwigProfileCollector($profile));\n</code></pre>"},{"location":"collectors/bridge/#version-2-and-3","title":"Version 2 and 3","text":"<p>This collector uses the class <code>Twig\\Extension\\ProfilerExtension</code> to collect info about rendered templates, blocks and macros. You need to inject the root <code>Twig\\Profiler\\Profile</code> into the collector:</p> <pre><code>use DebugBar\\Bridge\\NamespacedTwigProfileCollector;\nuse Twig\\Environment;\nuse Twig\\Extension\\ProfilerExtension;\nuse Twig\\Loader\\FilesystemLoader;\nuse Twig\\Profiler\\Profile;\n\n$loader = new FilesystemLoader('.');\n$env = new Environment($loader);\n$profile = new Profile();\n$env-&gt;addExtension(new ProfilerExtension($profile));\n$debugbar-&gt;addCollector(new NamespacedTwigProfileCollector($profile));\n</code></pre>"},{"location":"collectors/bridge/#optional-debugbar-twig-extensions","title":"Optional debugbar twig extensions","text":"<p>You can optionally use <code>DebugBar\\Bridge\\Twig\\TimeableTwigExtensionProfiler</code> in place of <code>Twig\\Profiler\\Profile</code> so render operation can be measured.</p> <pre><code>use Twig\\Environment;\nuse Twig\\Loader\\FilesystemLoader;\nuse Twig\\Profiler\\Profile;\n\n$loader = new FilesystemLoader('.');\n$env = new Environment($loader);\n$profile = new Profile();\n\n$env-&gt;addExtension(new DebugBar\\Bridge\\Twig\\TimeableTwigExtensionProfiler($profile, $debugbar['time']));\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\TwigProfileCollector($profile));\n</code></pre> <p>Other optional extensions add functions and tags for debugbar integration into templates.</p> <pre><code>use Twig\\Environment;\nuse Twig\\Loader\\FilesystemLoader;\nuse Twig\\Profiler\\Profile;\n\n$loader = new FilesystemLoader('.');\n$env = new Environment($loader);\n$profile = new Profile();\n\n// enable {% measure 'foo' %} {% endmeasure %} tags for time measure on templates\n// this extension adds timeline items to TimeDataCollector\n$twig-&gt;addExtension(new DebugBar\\Bridge\\Twig\\MeasureTwigExtension($debugbar['time']));\n\n$twig-&gt;enableDebug(); // if Twig\\Environment debug is disabled, dump/debug are ignored\n\n// enable {{ dump('foo') }} function on templates\n// this extension allows dumping data using debugbar DataFormatter\n$twig-&gt;addExtension(new DebugBar\\Bridge\\Twig\\DumpTwigExtension());\n\n// enable {{ debug('foo') }} function on templates\n// this extension allows debugging in MessageCollector\n$twig-&gt;addExtension(new DebugBar\\Bridge\\Twig\\DebugTwigExtension($debugbar['messages']));\n\n$debugbar-&gt;addCollector(new DebugBar\\Bridge\\TwigProfileCollector($profile));\n</code></pre>"},{"location":"docs/","title":"Getting started","text":""},{"location":"docs/#installation","title":"Installation","text":"<p>The best way to install DebugBar is using Composer with the following command:</p> <pre><code>composer require --dev php-debugbar/php-debugbar\n</code></pre>"},{"location":"docs/#quick-start","title":"Quick start","text":"<p>DebugBar is very easy to use and you can add it to any of your projects in no time. The easiest way is using the <code>render()</code> functions</p> <pre><code>&lt;?php\n\n// Require the Composer autoloader, if not already loaded\nrequire 'vendor/autoload.php';\n\nuse DebugBar\\StandardDebugBar;\n\n$debugbar = new StandardDebugBar();\n$debugbarRenderer = $debugbar-&gt;getJavascriptRenderer();\n\n$debugbar[\"messages\"]-&gt;addMessage(\"hello world!\");\n?&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;?php echo $debugbarRenderer-&gt;renderHead() ?&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        ...\n        &lt;?php echo $debugbarRenderer-&gt;render() ?&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The DebugBar uses DataCollectors to collect data from your PHP code. Some of them are automated but others are manual. Use the <code>DebugBar</code> like an array where keys are the collector names. In our previous example, we add a message to the <code>MessagesCollector</code>:</p> <pre><code>$debugbar[\"messages\"]-&gt;addMessage(\"hello world!\");\n</code></pre> <p><code>StandardDebugBar</code> activates the following collectors:</p> <ul> <li><code>MemoryCollector</code> (memory)</li> <li><code>MessagesCollector</code> (messages)</li> <li><code>PhpInfoCollector</code> (php)</li> <li><code>RequestDataCollector</code> (request)</li> <li><code>TimeDataCollector</code> (time)</li> <li><code>ExceptionsCollector</code> (exceptions)</li> </ul> <p>Learn more about DebugBar in the docs.</p>"},{"location":"docs/#demo","title":"Demo","text":"<p>To run the demo, clone this repository and start the Built-In PHP webserver from the root:</p> <pre><code>php -S localhost:8000\n</code></pre> <p>Then visit http://localhost:8000/demo/</p>"},{"location":"docs/#testing","title":"Testing","text":"<p>To test, run <code>php vendor/bin/phpunit</code>. To debug Browser tests, you can run <code>PANTHER_NO_HEADLESS=1 vendor/bin/phpunit --debug</code>. Run <code>vendor/bin/bdi detect drivers</code> to download the latest drivers.</p>"},{"location":"docs/ajax-and-stack/","title":"AJAX and Stacked data","text":""},{"location":"docs/ajax-and-stack/#ajax","title":"AJAX","text":"<p>As mentioned in the previous chapter, if you are performing AJAX requests which return HTML content, you can use <code>JavascriptRenderer::render(false)</code>.</p> <p>In the case you are sending back non-HTML data (eg: JSON), the DebugBar can send data to the client using HTTP headers using the <code>sendDataInHeaders()</code> method (no need to use the <code>JavascriptRenderer</code>):</p> <pre><code>$debugbar = new DebugBar();\n// ...\n$debugbar-&gt;sendDataInHeaders();\n</code></pre> <p>On the client side, an instance of <code>PhpDebugBar.AjaxHandler</code> will parse the headers and add the dataset to the debugbar.</p> <p>The AjaxHandler automatically binds to jQuery's ajaxComplete event so if you are using jQuery, you have nothing to configure.</p> <p>If you're not using jQuery, you can call <code>AjaxHandler.handle(xhr)</code>. If you are using the <code>JavascriptRenderer</code> initialization, the instance of <code>AjaxHandler</code> is stored in the <code>ajaxHandler</code> property of the <code>DebugBar</code> object.</p> <pre><code>debugbar.ajaxHandler.handle(xhr);\n</code></pre> <p>If you are sending a lot of data through headers, it may cause problems with your browser. Instead you can use a storage handler (see Storage chapter) and the open handler (see Open Handler chapter) to load the data after an ajax request. Use true as the first argument of <code>sendDataInHeaders()</code>.</p> <pre><code>$debugbar = new DebugBar();\n\n// define a storage\n$debugbar-&gt;setStorage(new DebugBar\\Storage\\FileStorage('/path/to/storage'));\n\n// define the open handler url\n$renderer = $debugbar-&gt;getJavascriptRenderer();\n$renderer-&gt;setOpenHandlerUrl('open.php');\n\n// ...\n\n$debugbar-&gt;sendDataInHeaders(true);\n</code></pre> <p>By default, the debug bar will immediately show new AJAX requests. If your page makes a lot of requests in the background (e.g. tracking), this can be disruptive. You can disable this behavior by calling <code>setAjaxHandlerAutoShow(false)</code> on the <code>JavascriptRenderer</code>, like this:</p> <pre><code>$renderer = $debugbar-&gt;getJavascriptRenderer();\n$renderer-&gt;setAjaxHandlerAutoShow(false);\n</code></pre>"},{"location":"docs/ajax-and-stack/#fetch","title":"Fetch","text":"<p>Fetch API is supported by wrapping <code>window.fetch</code> so that the promise is also passed through to the debugbar AJAX handler.</p> <p>If you find your fetch requests are not showing up in debugbar, you're probably initializing your JavaScript client library (e.g. Apollo) before debugbar has loaded, try adding <code>defer</code> onto your script tags, or moving them after the injected debugbar JavaScript.</p>"},{"location":"docs/ajax-and-stack/#stacked-data","title":"Stacked data","text":"<p>Some times you need to collect data about a request but the page won't actually be displayed. The best example of that is during a redirect. You can use the debug bar storage mechanism to store the data and re-open it later but it can be cumbersome while testing a redirect page.</p> <p>The solution is to use stacked data. The debug bar can temporarily store the collected data in the session until the next time it will be displayed. Simply call <code>DebugBar::stackData()</code> instead of rendering the debug bar.</p> <p>PHP's session must be started before using this feature.</p> <p>Note: The stacked data feature will use the storage mechanism if it's enabled instead of storing the data in the session.</p> <pre><code>$debugbar = new DebugBar();\n// ...\n$debugbar-&gt;stackData();\n</code></pre> <p>Stacked data are rendered each time the debug bar is rendered using the <code>JavascriptRenderer</code>.</p>"},{"location":"docs/data-collectors/","title":"Collecting Data","text":""},{"location":"docs/data-collectors/#using-collectors","title":"Using collectors","text":"<p>Collectors can be added to your debug bar using <code>addCollector()</code>.</p> <pre><code>$debugbar = new DebugBar();\n$debugbar-&gt;addCollector(new DataCollector\\RequestDataCollector());\n</code></pre> <p>Each collector as a unique name as defined by its <code>getName()</code> method. You can access collectors using <code>getCollector($name)</code>.</p> <pre><code>$debugbar-&gt;addCollector(new DataCollector\\MessagesCollector());\n$debugbar-&gt;getCollector('messages')-&gt;addMessage(\"foobar\");\n// or:\n$debugbar['messages']-&gt;addMessage(\"foobar\");\n</code></pre> <p>Data will be collected from them when the debug bar is rendered. You can however collect the data earlier using <code>collect()</code>.</p> <pre><code>$debugbar-&gt;collect();\n</code></pre>"},{"location":"docs/data-collectors/#creating-collectors","title":"Creating collectors","text":"<p>Collectors must implement the <code>DebugBar\\DataCollector\\DataCollectorInterface</code>. They may subclass <code>DebugBar\\DataCollector\\DataCollector</code> which provides utility methods.</p> <p>Collectors must provide a <code>getName()</code> function returning their unique name and a <code>collect()</code> function returning some json-encodable data. The latter will be called at the same time the <code>DebugBar::collect()</code> method is called.</p> <pre><code>class MyDataCollector extends DebugBar\\DataCollector\\DataCollector\n{\n    public function collect()\n    {\n        return array(\"uniqid\" =&gt; uniqid());\n    }\n\n    public function getName()\n    {\n        return 'mycollector';\n    }\n}\n\n$debugbar-&gt;addCollector(new MyDataCollector());\n</code></pre> <p>This however won't show anything in the debug bar as no information are provided on how to display these data. You could do that manually as you'll see in later chapter or implement the <code>DebugBar\\DataSource\\Renderable</code> interface.</p> <p>To implement it, you must define a <code>getWidgets()</code> function which returns an array of key/value pairs where key are control names and values control options as defined in <code>JavascriptRenderer::addControl($name, $options)</code> (see Rendering chapter).</p> <pre><code>class MyDataCollector extends DebugBar\\DataCollector\\DataCollector implements DebugBar\\DataCollector\\Renderable\n{\n    // ...\n\n    public function getWidgets()\n    {\n        return array(\n            \"mycollector\" =&gt; array(\n                \"icon\" =&gt; \"cogs\",\n                \"tooltip\" =&gt; \"uniqid()\",\n                \"map\" =&gt; \"uniqid\",\n                \"default\" =&gt; \"''\"\n            )\n        );\n    }\n}\n</code></pre> <p>This will have the result of adding a new indicator to the debug bar.</p> <p>When implementing the <code>Renderable</code> interface, you may use widgets which are not provided with the default install. You can add new assets by implementing the <code>DebugBar\\DataCollector\\AssetProvider</code> interface.</p> <p>To implement it, you must define the <code>getAssets()</code> method. It must return an array with the following keys:</p> <ul> <li><code>base_path</code>: base path of assets (optional, if omitted or null, will use the base path of the <code>JavascriptRenderer</code>)</li> <li><code>base_url</code>: base url of assets (optional, same as <code>base_path</code>)</li> <li><code>css</code>: an array of css filenames</li> <li><code>js</code>: an array of javascript filenames</li> <li><code>inline_css</code>: an array map of content ID to inline CSS content (not including <code>&lt;style&gt;</code> tag)</li> <li><code>inline_js</code>: an array map of content ID to inline JS content (not including <code>&lt;script&gt;</code> tag)</li> <li><code>inline_head</code>: an array map of content ID to arbitrary inline HTML content (typically    <code>&lt;style&gt;</code>/<code>&lt;script&gt;</code> tags); it will be embedded within the <code>&lt;head&gt;</code> element</li> </ul> <p>All keys are optional.</p> <p>Ideally, you should store static assets in filenames that are returned via the normal <code>css</code>/<code>js</code> keys.  However, the inline asset elements are useful when integrating with 3rd-party libraries that require static assets that are only available in an inline format.</p> <p>The inline content arrays require special string array keys to identify the content:  the debug bar will use them to deduplicate.  This is particularly useful if multiple instances of the same asset provider are used.  Inline assets from all collectors are merged together into the same array, so these content IDs effectively deduplicate the inline assets.</p> <p>Example:</p> <pre><code>class MyDbCollector extends DebugBar\\DataCollector\\DataCollector implements DebugBar\\DataCollector\\Renderable, DebugBar\\DataCollector\\AssetProvider\n{\n    // ...\n\n    public function getWidgets()\n    {\n        return array(\n            \"database\" =&gt; array(\n                \"icon\" =&gt; \"inbox\",\n                \"widget\" =&gt; \"PhpDebugBar.Widgets.SQLQueriesWidget\",\n                \"map\" =&gt; \"pdo\",\n                \"default\" =&gt; \"[]\"\n            )\n        );\n    }\n\n    public function getAssets()\n    {\n        return array(\n            'css' =&gt; 'widgets/sqlqueries/widget.css',\n            'js' =&gt; 'widgets/sqlqueries/widget.js',\n\n            // Ordinarily, inline assets like these should be avoided whenever possible:\n            'inline_css' =&gt; array(\n                'db_widget_css' =&gt; 'div.myelement { color: #000; }',\n            ),\n            'inline_js' =&gt; array(\n                'db_widget_js' =&gt; 'alert(\"Db widget asset loaded.\");'\n            ),\n            'inline_head' =&gt; array(\n                'db_widget_head' =&gt; '&lt;meta content=\"Arbitrary HTML content\"&gt;'\n            )\n        );\n    }\n}\n</code></pre>"},{"location":"docs/data-formatter/","title":"Data Formatter","text":""},{"location":"docs/data-formatter/#html-variable-formatting","title":"HTML variable formatting","text":"<p>PHP Debug Bar integrates with Symfony's VarDumper component to provide interactive HTML-based variable dumps. This is accomplished via the <code>DebugBar\\DataFormatter\\DebugBarVarDumper</code> class, which wraps VarDumper functionality for use by the debug bar.</p> <p>Debug bar users who wish to take advantage of this feature must ensure that they properly render inline assets when rendering the debug bar. That's because collectors using the variable dumper return the static assets of the HTML variable dumper, which includes inline assets.</p> <p>By default, collectors inheriting from <code>DebugBar\\DataCollector\\DataCollector</code> will use the <code>DebugBarVarDumper</code> instance specified by the static <code>DataCollector::setDefaultVarDumper</code> function. This can be overridden on a per-collector basis by the non-static <code>DataCollector::setVarDumper</code> function.</p> <pre><code>// Modify default options used globally by all collectors\nDataCollector::getDefaultVarDumper()-&gt;mergeClonerOptions(array(\n    'max_items' =&gt; 50,\n));\n\n// Modify options for a specific collector\n$varDumper = new DebugBarVarDumper();\n$varDumper-&gt;mergeDumperOptions(array(\n    'max_string' =&gt; 100,\n));\n$collector-&gt;setVarDumper($varDumper);\n</code></pre> <p>VarDumper has two key classes that are used by <code>DebugBarVarDumper</code>. The options can be set using the <code>mergeClonerOptions</code>, <code>resetClonerOptions</code>, <code>mergeDumperOptions</code>, and <code>resetDumperOptions</code> methods on <code>DebugBarVarDumper</code>.</p> <ul> <li><code>VarCloner</code>: Cloners copy the contents of a variable into a serializable format. They are    intended to run as fast as possible; advanced rendering/formatting is saved for the dumper.    Classes known as casters control how particular data types are serialized; if no caster exists,    then a generic serialization is done. You can specify custom casters using the    <code>additional_casters</code> option; the default list of casters can be overridden with the <code>casters</code>    option. Finally, the number of items and maximum string length to clone can be controlled via the    <code>max_items</code>, <code>min_depth</code>, and <code>max_string</code> options; consult the    VarDumper documentation    for more information on these options, which have a considerable performance impact. Note that    the <code>min_depth</code> option requires VarDumper 3.4 or newer.</li> <li><code>HtmlDumper</code>: Dumpers format cloned data for a particular destination, such as command-line or    HTML. <code>DebugBarVarDumper</code> only uses the <code>HtmlDumper</code>. Custom styles can be specified via the    <code>styles</code> option, but this is not generally needed. If using VarDumper 3.2 or newer, you may also    specify the <code>expanded_depth</code>, <code>max_string</code>, and <code>file_link_format</code> options. <code>expanded_depth</code>    controls the tree depth that should be expanded by default upon initial rendering. <code>max_string</code>    can be used to truncate strings beyond the initial truncation done by the cloner.    <code>file_link_format</code> is a format string used to generate links to source code files.</li> </ul> <p>A collector wishing to take advantage of this feature must call the <code>renderVar()</code> function and return the HTML result as part of the request dataset:</p> <pre><code>public function collectVariable($v)\n{\n    // This will clone and then dump the variable in one operation:\n    $this-&gt;variableHtml = $this-&gt;getVarDumper()-&gt;renderVar($v);\n}\n\npublic function collect()\n{\n    return array('variableHtml' =&gt; $this-&gt;variableHtml);\n}\n</code></pre> <p>The collector may then render the raw HTML in a Javascript widget:</p> <pre><code>if (value.variableHtml) {\n    var val = $('&lt;span /&gt;').html(value.variableHtml).appendTo(otherElement);\n}\n</code></pre> <p>If the collector takes advantage of the variable dumper, as shown above, then it must also implement the <code>AssetProvider</code> interface and include the assets of the variable dumper. This does not take place by default, because not all collectors will use the variable dumper.</p> <pre><code>class MyCollector extends DataCollector implements Renderable, AssetProvider\n{\n    public function getAssets() {\n        return $this-&gt;getVarDumper()-&gt;getAssets();\n    }\n}\n</code></pre> <p>You might want to clone a variable initially, and only dump it at a later time. This is supported by the <code>captureVar()</code> and <code>renderCapturedVar()</code> functions. It's also possible to render only portions of a cloned variable at a time.</p> <pre><code>$testData = array('one', 'two', 'three');\n$cloned_variable = $this-&gt;getVarDumper()-&gt;captureVar($testData);\n\n// Later, when you want to render it. Note the second parameter is $seekPath; here we specify\n// to only render the second array element (index 1). $html will therefore only contain 'two'.\n$html = $this-&gt;getVarDumper()-&gt;renderCapturedVar($cloned_variable, array(1));\n</code></pre>"},{"location":"docs/data-formatter/#text-formatting","title":"Text formatting","text":"<p>An instance of <code>DebugBar\\DataFormatter\\DataFormatterInterface</code> is used by collectors to format variables into a text-only format.</p> <p>The default instance is <code>DebugBar\\DataFormatter\\DataFormatter</code>. This can be modified using <code>DebugBar\\DataCollector\\DataCollector::setDefaultDataFormatter()</code>.</p> <p>You can use a custom formatter for each collector using <code>DataCollector::setDataFormatter()</code>.</p> <p>For general-purpose variable formatting, it's recommended to use the HTML variable dumper, described earlier.</p>"},{"location":"docs/http-drivers/","title":"HTTP drivers","text":"<p>Some features of the debug bar requires sending http headers or using the session. Many frameworks implement their own mechanism on top of PHP native features.</p> <p>To make integration with other frameworks as easy as possible, the <code>DebugBar</code> object uses an instance of <code>DebugBar\\HttpDriverInterface</code> to access those features.</p> <p><code>DebugBar\\PhpHttpDriver</code>, which uses native PHP mechanisms, is provided and will be used if no other driver are specified.</p>"},{"location":"docs/javascript-bar/","title":"Javascript Bar","text":"<p>This section is here to document the inner workings of the client side debug bar. Nothing described below is needed to run the debug bar in a normal way.</p> <p>The default client side implementation of the debug bar is made entirely in Javascript and is located in the debugbar.js file.</p> <p>It adds a bottom-anchored bar which can have tabs and indicators. The bar can be in an open or close state. When open, the tab panel is visible. An indicator is a piece of information displayed in the always-visible part of the bar.</p> <p>The bar handles multiple datasets by displaying a select box which allows you to switch between them.</p> <p>The state of the bar (height, visibility, active panel) can be saved between requests (enabled in the standard bar).</p> <p>Each panel is composed of a widget which is used to display the data from a data collector. Some common widgets are provided in the widgets.js file.</p> <p>The <code>PhpDebugBar</code> namespace is used for all objects and the only dependencies are jQuery and FontAwesome (css). FontAwesome is optional but is used to add nice icons!</p> <p>The main class is <code>PhpDebugBar.DebugBar</code>. It provides the infrastructure to manage tabs, indicators and datasets.</p> <p>When initialized, the <code>DebugBar</code> class adds itself to the <code>&lt;body&gt;</code> of the page. It is empty by default.</p>"},{"location":"docs/javascript-bar/#tabs-and-indicators","title":"Tabs and indicators","text":"<p>Controls (ie. tabs and indicators) are uniquely named. You can check if a control exists using <code>isControl(name)</code>.</p> <p>Tabs can be added using the <code>createTab(name, widget, title)</code> function. The third argument is optional and will be computed from the name if not provided.</p> <pre><code>var debugbar = new PhpDebugBar.DebugBar();\ndebugbar.createTab(\"messages\", new PhpDebugBar.Widgets.MessagesWidget());\n</code></pre> <p>Indicators can be added using <code>createIndicator(name, icon, tooltip, position)</code>. Only <code>name</code> is required in this case. <code>icon</code> should be the name of a FontAwesome icon. <code>position</code> can either be right (default) or left.</p> <pre><code>debugbar.createIndicator(\"time\", \"cogs\", \"Request duration\");\n</code></pre> <p>You may have noticed that the data to use inside these controls is not specified at the moment. Although it could be specified when initialized, it is better to use data mapping to support dynamically changing the data set.</p>"},{"location":"docs/javascript-bar/#data-mapping","title":"Data mapping","text":"<p>To enable dynamically changing the data sets, we need to specify which values should be feed into which controls. This can be done using <code>setDataMap(map)</code> which takes as argument an object where properties are control names. Values should be arrays where the first item is the property from the data set and the second a default value.</p> <pre><code>debugbar.setDataMap({\n    \"messages\": [\"messages\", []],\n    \"time\": [\"time.duration_str\", \"0ms\"]\n});\n</code></pre> <p>You can notice that nested properties can also be accessed using the dot notation.</p> <p>In this mapping, <code>data[\"messages\"]</code> will be fed to the messages tab and <code>data[\"time\"][\"duration_str\"]</code> will be fed to the time indicator.</p> <p>Note: you can append mapping info using <code>addDataMap(map)</code></p>"},{"location":"docs/javascript-bar/#datasets","title":"Datasets","text":"<p>Although you shouldn't have to do anything regarding managing datasets, it is interesting to know a few functions related to them.</p> <p><code>addDataSet(data, id)</code> adds a dataset to the bar. The select box that allows to switch between sets is only displayed if more than one are added. <code>id</code> is optional and will be auto-generated if not specified.</p> <p><code>showDataSet(id)</code> allows you to switch to a specific dataset.</p>"},{"location":"docs/javascript-bar/#widgets","title":"Widgets","text":"<p>Widgets should inherit from the <code>PhpDebugBar.Widget</code> class which is used as the base of every visual component in the debug bar.</p> <p>New widgets can be created using <code>extend()</code>:</p> <pre><code>var MyWidget = PhpDebugBar.Widget.extend({\n    // class properties\n});\n</code></pre> <p>The Widget class defines a <code>set(attr, value)</code> function which can be used to set the value of attributes.</p> <p>Using <code>bindAttr(attr, callback)</code>, you can trigger a callback every time the value of the attribute is changed. <code>callback</code> can also be a <code>jQuery</code> object and in that case it will use the <code>text()</code> function to fill the element.</p> <p>Widgets should define a <code>render()</code> function which initializes the widget elements.</p> <p><code>initialize(options)</code> will always be called after the constructor.</p> <pre><code>var MyWidget = PhpDebugBar.Widget.extend({\n\n    tagName: 'div', // optional as 'div' is the default\n\n    className: 'mywidget',\n\n    render: function() {\n        this.bindAttr('data', this.$el);\n    }\n\n});\n\n// ----\n\ndebugbar.createTab(\"mytab\", new MyWidget());\ndebugbar.addDataMap({\"mytab\": [\"mydata\", \"\"]});\n</code></pre> <p>Widgets for bundled data collectors are included as well as more generic widgets that you can build on top of. They are located in widgets.js in the <code>PhpDebugBar.Widgets</code> namespace.</p> <p>Generic widgets:</p> <ul> <li><code>ListWidget</code>: renders an array as a UL list</li> <li><code>KVListWidget</code>: renders a hash as a DL list</li> <li><code>VariablesListWidget</code>: an extension of <code>KVListWidget</code> to display a list of variables</li> <li><code>IFrameWidget</code>: renders an iframe</li> </ul> <p>Data collectors related widgets:</p> <ul> <li><code>MessagesWidget</code>: for the <code>MessagesCollector</code></li> <li><code>TimelineWidget</code>: for the <code>TimeDataCollector</code></li> <li><code>ExceptionWidget</code>: for the <code>ExceptionCollector</code></li> <li><code>SQLQueriesWidget</code>: for the <code>PDOCollector</code></li> <li><code>TemplatesWidget</code>: for the <code>TwigCollector</code></li> </ul>"},{"location":"docs/javascript-bar/#custom-tabs-and-indicators","title":"Custom tabs and indicators","text":"<p>Behind the scene, <code>createTab()</code> and <code>createIndicator()</code> use <code>addTab(name, tab)</code> and <code>addIndicator(name, indicator)</code>. Tabs are objects of type <code>PhpDebugBar.DebugBar.Tab</code> and indicators of type <code>PhpDebugBar.DebugBar.Indicator</code>. These classes subclass <code>PhpDebugBar.Widget</code> which makes it easy to create custom tabs or indicators.</p> <pre><code>var LinkIndicator = PhpDebugBar.DebugBar.Indicator.extend({\n\n    tagName: 'a',\n\n    render: function() {\n        LinkIndicator.__super__.render.apply(this);\n        this.bindAttr('href', function(href) {\n            this.$el.attr('href', href);\n        });\n    }\n\n});\n\n// ----\n\ndebugbar.addIndicator('phpdoc', new LinkIndicator({ href: 'http://doc.php.com', title: 'PHP doc' }));\n</code></pre>"},{"location":"docs/javascript-bar/#openhandler","title":"OpenHandler","text":"<p>An OpenHandler object can be provided using <code>setOpenHandler()</code>. The object is in charge of loading datasets. The only requirement is to provide a <code>show()</code> method which takes as only parameter a callback which expects an id and data parameter.</p> <p>The default implementation is <code>PhpDebugBar.OpenHandler</code> which must be use in conjunction with the server side <code>DebugBar\\OpenHandler</code> (see previous section).</p> <pre><code>debugbar.setOpenHandler(new PhpDebugBar.OpenHandler({ url: \"open.php\" }));\n</code></pre>"},{"location":"docs/openhandler/","title":"Open handler","text":"<p>The debug bar can open previous sets of collected data which were stored using a storage handler (see previous section). To do so, it needs to be provided an url to an open handler.</p> <p>An open handler must respect a very simple protocol. The default implementation is <code>DebugBar\\OpenHandler</code>.</p> <pre><code>$openHandler = new DebugBar\\OpenHandler($debugbar);\n$openHandler-&gt;handle();\n</code></pre> <p>Calling <code>handle()</code> will use data from the <code>$_REQUEST</code> array and echo the output. The function also supports input from other source if you provide an array as first argument. It can also return the data instead of echoing (use false as second argument) and not send the content-type header (use false as third argument).</p> <p>One you have setup your open handler, tell the <code>JavascriptRenderer</code> its url.</p> <pre><code>$renderer-&gt;setOpenHandlerUrl('open.php');\n</code></pre> <p>This adds a button in the top right corner of the debug bar which allows you to browse and open previous sets of collected data.</p>"},{"location":"docs/rendering/","title":"Rendering","text":"<p>Rendering is performed using the <code>DebugBar\\JavascriptRenderer</code> class. It contains all the useful functions to included the needed assets and generate a debug bar.</p> <pre><code>$renderer = $debugbar-&gt;getJavascriptRenderer();\n</code></pre>"},{"location":"docs/rendering/#assets","title":"Assets","text":"<p>The debug bar relies on some css and javascript files which needs to be included into your webpage. They are located in the src/DebugBar/Resources folder. Additionally, asset providers may provide inline assets that have to be embedded directly in the HTML.  This can be done in four ways:</p> <ul> <li>Using <code>JavascriptRenderer::renderHead()</code> which will returns a string with    the needed script and link tags</li> <li>Using Assetic and    <code>JavascriptRenderer::getAsseticCollection()</code></li> <li>Dumping the assets yourself using <code>JavascriptRenderer::dumpCssAssets()</code>,    <code>JavascriptRenderer::dumpJsAssets()</code>, and <code>JavascriptRenderer::dumpHeadAssets()</code>.</li> <li>Retrieving filenames and inline content of assets using <code>JavascriptRenderer::getAssets()</code>    and doing something with it</li> </ul> <p>I would recommend using the second method as Assetic is a very powerful asset manager but the other methods are provided to quickly integrate the debug bar into any projects.</p> <p>You can define the base url of your assets using <code>setBaseUrl()</code>. This is needed in 99% of cases.</p> <p>Using <code>renderHead()</code>:</p> <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        ...\n        &lt;?php echo $renderer-&gt;renderHead() ?&gt;\n        ...\n    &lt;/head&gt;\n    ...\n&lt;/html&gt;\n</code></pre> <p>Using Assetic:</p> <pre><code>list($cssCollection, $jsCollection, $inlineHeadCollection) = $renderer-&gt;getAsseticCollection();\n</code></pre> <p>Dumping the assets:</p> <pre><code>header('Content-Type: text/javascript');\n$renderer-&gt;dumpJsAssets();\n</code></pre> <p>Retrieving the assets:</p> <pre><code>list($cssFiles, $jsFiles, $inlineCss, $inlineJs, $inlineHead) = $renderer-&gt;getAssets();\n</code></pre> <p>Note that you can only use the debug bar assets and manage the dependencies by yourself using <code>$renderer-&gt;setIncludeVendors(false)</code>. Instead of false, css or js may be used to only include css or js assets of vendors.</p>"},{"location":"docs/rendering/#managing-jquery-conflicts","title":"Managing jQuery conflicts","text":"<p>When the debug bar script is included, it will be bound to the current jQuery object. The default action is to call <code>jQuery.noConflict(true)</code> after this is done.</p> <p>This has two implications:</p> <ul> <li>jQuery won't be available anymore if you didn't include your own version    before including the debug bar's vendors</li> <li>your own version will be restored.</li> </ul> <p>If you use <code>JavascriptRenderer::setIncludeVendors()</code> to disable the inclusion of js vendors (ie. jquery), <code>jQuery.noConflict(true)</code> won't be called.</p> <p>You can manage whether <code>jQuery.noConflict(true)</code> should be called or not using <code>JavascriptRenderer::setEnableJqueryNoConflict()</code>.</p>"},{"location":"docs/rendering/#the-javascript-object","title":"The javascript object","text":"<p>The renderer will generate all the needed code for your debug bar. This means initializing the DebugBar js object, adding tabs and indicators, defining a data map, etc...</p> <p>Data collectors can provide their own controls when implementing the <code>DebugBar\\DataCollector\\Renderable</code> interface as explained in the Collecting Data chapter.</p> <p>Thus in almost all cases, you should only have to use <code>render()</code> right away:</p> <pre><code>&lt;html&gt;\n    ...\n    &lt;body&gt;\n        &lt;?php echo $renderer-&gt;render() ?&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>This will print the initialization code for the toolbar and the dataset for the request. When you are performing AJAX requests, you do not want to initialize a new toolbar but add the dataset to the existing one. You can disable initialization using <code>false</code> as the first argument of <code>render()</code>.</p> <pre><code>&lt;p&gt;my ajax content&lt;/p&gt;\n&lt;?php echo $renderer-&gt;render(false) ?&gt;\n</code></pre>"},{"location":"docs/rendering/#controlling-object-initialization","title":"Controlling object initialization","text":"<p>You can further control the initialization of the javascript object using <code>setInitialization()</code>. It takes a bitwise value made out of the constants <code>INITIALIZE_CONSTRUCTOR</code> and <code>INITIALIZE_CONTROLS</code>. The first one controls whether to initialize the variable (ie. <code>var debugbar = new DebugBar()</code>). The second one whether to initialize all the controls (ie. adding tab and indicators as well as data mapping).</p> <p>You can also control the class name of the object using <code>setJavascriptClass()</code> and the name of the instance variable using <code>setVariableName()</code>.</p> <p>Let's say you have subclassed <code>PhpDebugBar.DebugBar</code> in javascript to do your own initialization. Your new object is called <code>MyDebugBar</code>.</p> <pre><code>$renderer-&gt;setJavascriptClass(\"MyDebugBar\");\n$renderer-&gt;setInitialization(JavascriptRenderer::INITIALIZE_CONSTRUCTOR);\n// ...\necho $renderer-&gt;render();\n</code></pre> <p>This has the result of printing:</p> <pre><code>&lt;script type=\"text/javascript\"&gt;\nvar phpdebugbar = new MyDebugBar();\nphpdebugbar.addDataSet({ ... });\n&lt;/script&gt;\n</code></pre> <p>Using <code>setInitialization(0)</code> will only render the addDataSet part.</p>"},{"location":"docs/rendering/#defining-controls","title":"Defining controls","text":"<p>Controls can be manually added to the debug bar using <code>addControl($name, $options)</code>. You should read the Javascript bar chapter before this section.</p> <p><code>$name</code> will be the name of your control and <code>$options</code> is a key/value pair array with these possible values:</p> <ul> <li>icon: icon name</li> <li>tooltip: string</li> <li>widget: widget class name</li> <li>map: a property name from the data to map the control to</li> <li>default: a js string, default value of the data map</li> <li>tab: class name of the tab object (to use a custom tab object)</li> <li>indicator: class name of the indicator object (to use a custom indicator object)</li> <li>position: position of the indicator ('left' of 'right', default to 'right')</li> </ul> <p>At least icon or widget are needed (unless tab or indicator are specified). If widget is specified, a tab will be created, otherwise an indicator. Any other options is also passed to the tab or indicator.</p> <pre><code>$renderer-&gt;addControl('messages', array(\n    \"widget\" =&gt; \"PhpDebugBar.Widgets.MessagesWidget\",\n    \"map\" =&gt; \"messages\",\n    \"default\" =&gt; \"[]\"\n));\n</code></pre> <p>You can disable a control using <code>disableControl($name)</code> and ignore any controls provided by a collector using <code>ignoreCollector($name)</code>.</p>"},{"location":"docs/storage/","title":"Storage","text":"<p>DebugBar supports storing collected data for later analysis. You'll need to set a storage handler using <code>setStorage()</code> on your <code>DebugBar</code> instance.</p> <pre><code>$debugbar-&gt;setStorage(new DebugBar\\Storage\\FileStorage('/path/to/dir'));\n</code></pre> <p>Each time <code>DebugBar::collect()</code> is called, the data will be persisted.</p>"},{"location":"docs/storage/#available-storage","title":"Available storage","text":""},{"location":"docs/storage/#file","title":"File","text":"<p>It will collect data as json files under the specified directory (which has to be writable).</p> <pre><code>$storage = new DebugBar\\Storage\\FileStorage($directory);\n</code></pre>"},{"location":"docs/storage/#redis","title":"Redis","text":"<p>Stores data inside a Redis hash. Uses Predis.</p> <pre><code>$storage = new DebugBar\\Storage\\RedisStorage($client);\n</code></pre>"},{"location":"docs/storage/#pdo","title":"PDO","text":"<p>Stores data inside a database.</p> <pre><code>$storage = new DebugBar\\Storage\\PdoStorage($pdo);\n</code></pre> <p>The table name can be changed using the second argument and sql queries can be changed using <code>setSqlQueries()</code>.</p>"},{"location":"docs/storage/#creating-your-own-storage","title":"Creating your own storage","text":"<p>You can easily create your own storage handler by implementing the <code>DebugBar\\Storage\\StorageInterface</code>.</p>"},{"location":"docs/storage/#request-id-generator","title":"Request ID generator","text":"<p>For each request, the debug bar will generate a unique id under which to store the collected data. This is perform using a <code>DebugBar\\RequestIdGeneratorInterface</code> object.</p> <p>If none are defined, the debug bar will automatically use <code>DebugBar\\RequestIdGenerator</code> which uses the <code>$_SERVER</code> array to generate the id.</p>"}]}